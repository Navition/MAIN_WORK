словари – изменяемые коллекции элементов **с произвольными индексами – ключами**. Если в списках элементы индексируются целыми числами, начиная с `0`, то в словарях — любыми ключами, в том числе в виде строк.

```python
languages = {'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг', 'C++': 'Бьёрн Страуструп'} 

print('Создателем языка C# является', languages['C' + '#'])
Выводит:
Создателем языка C# является Андерс Хейлсберг
```
# **Создание**

```python
# пустые словари
d = {}
d = dict()

# ключи и значения
juice = {'яблоко': 3, 'банан': 6, 'апельсин': 4, 'груша': 2}
# 'яблоко' - ключ, 3 - значение
print(juice)

# значения могут быть разных типов
food = {
    "Фрукты": ["яблоко", "банан", "груша"],
    "Овощи": ["морковь", "помидор", "лук"],
    "Мясо": ["курица", "говядина"],
    "Напитки": ["чай", "кофе", "сок"]
}
print(food)
```
## Создание словаря с помощью функции dict()

***Если ключи словаря — строки без каких-либо специальных символов, то для создания словаря можно использовать функцию `dict()`.

```python
info = dict(name='Timur', age=28, job='Teacher')
```
**создает словарь с тремя элементами, ключами которого служат строки `'name'`, `'age'`, `'job'`, а значениями – `'Timur'`, `28`, `'Teacher'`.
## Создание словаря на основании списков и кортежей

**Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением.
```python
info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')] # список кортежей 
info_dict = dict(info_list) # создаем словарь на основе списка кортежей
```

**создает словарь с тремя элементами, где ключи — строки `name`, `age`, `job`, а соответствующие им значения — `'Timur'`, `28`, `'Teacher'`.

**Аналогично работает приведенный ниже код: 

```python
info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков

info_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков
```

 ## **Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом `fromkeys()`.

**Приведенный ниже код:

```python
dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')
```

**создает словарь с тремя элементами, где ключи — строки `'name'`, `'age'`, `'job'`, а соответствующие им значения: `'Missed information'`, `'Missed information'`, `'Missed information'`.

![](data:image/png;base64,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)**Если методу `fromkeys()` не передать второй параметр, то по умолчанию присваивается значение `None`.

### **Вывод ключей и значений**

```python
print(juice['груша'])           # вывод значения по ключу (индексы тут не работают)
print(juice.keys())             # список ключей
print(list(juice.values()))     # список значений
print(juice.items())            # (ключ, значение)
# эти методы использует отдельный тип данных, и методы списков тут работать не будут
```

### **Изменение словаря**

```python
# добавление / изменение
juice = {'яблоко': 3, 'банан': 6, 'апельсин': 4, 'груша': 2}
print(juice)
juice['клубника'] = 3
print(juice)
juice.update({'слива' : 1, "малина" : 5}) # объединение словарей
print(juice)
```

```python
# изменение
print(juice['яблоко'])
juice['яблоко'] = 2
print(juice['яблоко'])

```

## **get:** посчитать количество букв

```python
text = 'tfyckophthalcemamerfberprritorialimoscopconversatrdepeionausaootballcylistbloicinteunkextratendenff'
result = {}
for num in text:
    result[num] = result.get(num, 0) + 1
print(result)
```

### Пустой словарь
**Пустой словарь можно создать двумя способами:

- с помощью пустых фигурных скобок;
- с помощью функции `dict()`.

**Приведенный ниже код:

```python
dict1 = {}
dict2 = dict()


print(dict1)
print(dict2)
print(type(dict1))
print(type(dict2))
```

**создает два пустых словаря и выводит:

```1c
{}
{}
<class 'dict'>
<class 'dict'>
```

![](data:image/png;base64,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)**создать пустое множество можно, только используя функцию `set()` , потому что пустые фигурные скобки зарезервированы для создания словаря.

### Вывод словаря

**Для вывода всего словаря можно использовать функцию `print()`:

```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг'}

info = dict(name = 'Timur', age = 28, job = 'Teacher')

print(languages)
print(info)
```

**Функция `print()` выводит на экран элементы словаря в фигурных скобках, разделенные запятыми:

```bash
{'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг'}
{'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```

# Основы работы со словарями

**Работа со словарями похожа на работу со списками, поскольку и словари, и списки содержат в качестве отдельных элементов пары: в словарях `ключ: значение`, в списках `индекс: значение`. 

### Функция len()

**Длиной словаря называется количество его элементов. Для определения длины словаря используют встроенную функцию `len()` (от слова length – длина).

**Приведенный ниже код:

```python
fruits = {'Apple': 70, 'Grape': 100, 'Banana': 80}
capitals = {'Россия': 'Москва', 'Франция': 'Париж'}

print(len(fruits))
print(len(capitals))
```

**выводит:

```no-highlight
3
2
```

### Оператор принадлежности in

**Оператор `in` позволяет проверить, содержит ли словарь заданный **ключ**.

**Рассмотрим код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

if 'Франция' in capitals:
    print('Столица Франции - это', capitals['Франция'])
```

**Такой код проверяет, содержит ли словарь `capitals` элемент с ключом `Франция`, и выводит соответствующий текст:  

```no-highlight
Столица Франции - это Париж
```

**Можно использовать оператор `in` вместе с логическим оператором `not`.

**Не забывайте, что при обращении по **несуществующему ключу**, возникнет ошибка во время выполнения программы.

**Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}

print(capitals['Англия'])
```

**приводит к возникновению ошибки:

```no-highlight
KeyError: 'Англия'
```

 **намного быстрее, чем на списках, поэтому если нужен многократный поиск в коллекции данных, словарь – подходящий выбор.

### Встроенные функции sum(), min(), max()

**Встроенная функция `sum()` принимает в качестве аргумента **словарь с числовыми ключами** и вычисляет сумму его ключей.

**Приведенный ниже код:

```python
my_dict = {10: 'Россия', 20: 'США', 30: 'Франция'}

print('Сумма всех ключей словаря =', sum(my_dict))
```

**выводит:

```no-highlight
Сумма всех ключей словаря = 60
```
 **Для корректной работы функции `sum()` ключами словаря должны быть именно числа.

**Встроенные функции `min()` и `max()` принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка `<`, `<=`, `>`, `>=` (числа, строки, и т.д.). 

**Приведенный ниже код:

```python
capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
months = {1: 'Январь', 2: 'Февраль', 3: 'Март'}

print('Минимальный ключ =', min(capitals))
print('Максимальный ключ =', max(months))
```

**выводит:

```no-highlight
Минимальный ключ = Россия
Максимальный ключ = 3
```

### Сравнение словарей

**Словари можно сравнивать между собой. Равные словари имеют одинаковое количество элементов и содержат равные элементы (`ключ: значение`). Для сравнения словарей используются операторы `==` и `!=`.

**Приведенный ниже код:

```python
months1 = {1: 'Январь', 2: 'Февраль'}
months2 = {1: 'Январь', 2: 'Февраль', 3: 'Март'}
months3 = {3: 'Март', 1: 'Январь', 2: 'Февраль'}

print(months1 == months2)
print(months2 == months3)
print(months1 != months3)
```

**выводит:

```no-highlight
False
True
True
```

## Примечания

****Примечание 1.** Обращение по индексу и срезы **недоступны** для словарей.

**Примечание 2.** Операция конкатенации `+` и умножения на число `*` **недоступны** для словарей.

**Примечание 3.** Словари нужно использовать в следующих случаях:

- Подсчет числа каких-то объектов. В этом случае нужно завести словарь, в котором ключи – названия объектов, а значения – их количество.
- Хранение каких-либо данных, связанных с объектом. Ключи — наименования объектов, значения — связанные с ними данные. Например, если нужно по названию месяца определить его порядковый номер, то это можно сделать при помощи словаря `num = {'January': 1, 'February': 2, 'March': 3, ...}`.

- Установка соответствия между объектами (например, “родитель-потомок”). Ключ – объект, значение – соответствующий ему объект.
- Если нужен обычный список, где максимальное значение индекса элемента очень велико, но при этом используются не все возможные индексы (так называемый “разреженный список”), то для экономии памяти можно использовать словарь.

# Методы словарей

**Словари, как и списки, имеют много полезных методов для упрощения работы с ними и решения повседневных задач. В прошлом уроке мы уже познакомились с тремя словарными методами:

- метод `items()` – возвращает словарные пары `ключ: значение`, как соответствующие им кортежи;
- метод `keys()` – возвращает список ключей словаря;
- метод `values()` – возвращает список значений словаря.

### Добавление и изменение элементов в словаре

**Чтобы изменить значение по определенному ключу в словаре, достаточно использовать индексацию вместе с оператором присваивания. При этом если ключ уже присутствует в словаре, его значение заменяется новым, если же ключ отсутствует – то в словарь будет добавлен новый элемент.

Приведенный ниже код:

```python
info = {'name': 'Sam',
        'age': 28,
        'job': 'Teacher'}

info['name'] = 'Timur'                  # изменяем значение по ключу name
info['email'] = 'timyr-guev@yandex.ru'  # добавляем в словарь элемент с ключом email

print(info)
```

**выводит (порядок элементов может отличаться):

```no-highlight
{'name': 'Timur', 'age': 28, 'job': 'Teacher', 'email': 'timyr-guev@yandex.ru'}
```

**Обратите внимание на отличие в поведении словарей и списков:**

- Если в списке `lst` нет элемента с индексом `7`, то попытка обращения к нему, например, с помощью строки кода `print(lst[7])` приведет к возникновению ошибки. И попытка присвоить ему значение `lst[7] = 100` тоже приведет к возникновению ошибки.
- Если в словаре `dct` нет элемента с ключом `name`, то попытка обращения к нему, например, с помощью строки кода `print(dct['name'])` приведет к возникновению ошибки. Однако попытка присвоить значение по отсутствующему ключу `dct['name'] = 'Timur'` ошибки не вызовет.

**Решим следующую задачу:** пусть задан список чисел `numbers`, где некоторые числа встречаются неоднократно. Нужно узнать, сколько именно раз встречается каждое из чисел.

```python
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]
```

Первый код, который приходит в голову, имеет вид:

```python
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]

result = {}
for num in numbers:
    result[num] += 1
```

Однако просто так сделать `result[num] += 1` нельзя, так как если ключа `num` в словаре еще нет, то возникнет ошибка `KeyError`.

Следующий программный код полностью решает поставленную задачу:

```python
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]

result = {}
for num in numbers:
    if num not in result:
        result[num] = 1
    else:
        result[num] += 1
```

Цикл `for` перебирает все элементы списка `numbers` и для каждого проверяет, присутствует ли он уже в качестве ключа в словаре `result`. Если значение отсутствует, значит, число встретилось впервые и мы инициируем значение `result[num] = 1`. Если значение уже присутствует в словаре, увеличим `result[num]` на единицу.

Этот код можно улучшить с помощью метода `get()`.

### Метод get()

Мы можем получить значение в словаре по ключу с помощью индексации, то есть квадратных скобок. Однако, как мы знаем, в случае отсутствия ключа будет происходить ошибка `KeyError`.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

print(info['name'])
```

выводит:

```no-highlight
Bob
```

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

print(info['salary'])
```

приводит к возникновению ошибки:

```no-highlight
KeyError: 'salary'
```

Для того чтобы избежать возникновения ошибки в случае отсутствия ключа в словаре, можно использовать метод `get()`, способный кроме ключа принимать и второй аргумент — значение, которое вернется, если заданного ключа нет. Когда второй аргумент не указан, то метод в случае отсутствия ключа возвращает `None`.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

item1 = info.get('salary')
item2 = info.get('salary', 'Информации о зарплате нет')

print(item1)
print(item2)
```

выводит:

```no-highlight
None
Информации о зарплате нет
```

   С помощью словарного метода `get()` можно упростить код в задаче о повторяющихся числах.

```python
numbers = [9, 8, 32, 1, 10, 1, 10, 23, 1, 4, 10, 4, 2, 2, 2, 2, 1, 10, 1, 2, 2, 32, 23, 23]

result = {}
for num in numbers:
    result[num] = result.get(num, 0) + 1
```

Цикл `for` перебирает все элементы списка `numbers` и для каждого элемента с помощью метода `get()` мы получаем либо его значение из словаря `result`, либо значение по умолчанию, равное `0`. К данному значению прибавляется единица, и результат записывается обратно в словарь по нужному ключу.

### Метод update()

Метод `update()` реализует своеобразную операцию конкатенации для словарей. Он объединяет ключи и значения одного словаря с ключами и значениями другого. При совпадении ключей в итоге сохранится значение словаря, указанного в качестве аргумента метода `update()`.

Приведенный ниже код:

```python
info1 = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

info2 = {'age': 30,
        'city': 'New York',
        'email': 'bob@web.com'}

info1.update(info2)

print(info1)
```

выводит (порядок элементов может отличаться):

```no-highlight
{'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}
```

В Python 3.9 появились операторы `|` и `|=`, которые реализуют операцию конкатенации словарей.

Приведенный ниже код:

```python
info1 = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

info2 = {'age': 30,
        'city': 'New York',
        'email': 'bob@web.com'}

info1 |= info2

print(info1)
```

аналогичен предыдущему коду.

### Метод setdefault()

Метод `setdefault()` позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует.

Метод принимает два аргумента:

-  `key`: ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
-  `default`: значение, которое будет использовано при добавлении нового элемента в словарь.

В зависимости от значений параметров `key` и `default` возможны следующие сценарии работы данного метода.

**Сценарий 1.** Если ключ `key` присутствует в словаре, то метод возвращает значение по заданному ключу (независимо от того, передан параметр `default` или нет).

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25}

name1 = info.setdefault('name')           # параметр default не задан           
name2 = info.setdefault('name', 'Max')    # параметр default задан

print(name1)
print(name2)
```

выводит:

```no-highlight
Bob
Bob
```

**Сценарий 2.** Если ключ `key` отсутствует в словаре, то метод вставляет переданное значение `default` по заданному ключу.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25}

job = info.setdefault('job', 'Dev')
print(info)
print(job)
```

выводит:

```no-highlight
{'name': 'Bob', 'age': 25, 'job': 'Dev'}
Dev
```

При этом если значение `default` не передано в метод, то вставится значение `None`.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25}

job = info.setdefault('job')
print(info)
print(job)
```

выводит:

```no-highlight
{'name': 'Bob', 'age': 25, 'job': None}
None
```

### Удаление элементов из словаря

Существует несколько способов удаления элементов из словаря:

- оператор `del`;
- метод `pop()`;
- метод `popitem()`;
- метод `clear()`.

### Оператор del

С помощью оператора `del` можно удалять элементы словаря по определенному ключу.

Приведенный ниже код:

```python
info = {'name': 'Sam',
        'age': 28,
        'job': 'Teacher',
        'email': 'timyr-guev@yandex.ru'}

del info['email']    # удаляем элемент имеющий ключ email
del info['job']      # удаляем элемент имеющий ключ job

print(info)
```

выводит (порядок элементов может отличаться):

```no-highlight
{'name': 'Sam', 'age': 28}
```
​   Если удаляемого ключа в словаре нет, возникнет ошибка `KeyError`.

### Метод pop()

Оператор `del` удаляет из словаря элемент по заданному ключу вместе с его значением. Если требуется получить само значение удаляемого элемента, то нужен метод `pop()`.   

Приведенный ниже код:

```python
info = {'name': 'Sam',
        'age': 28,
        'job': 'Teacher',
        'email': 'timyr-guev@yandex.ru'}

email = info.pop('email')          # удаляем элемент по ключу email, возвращая его значение
job = info.pop('job')              # удаляем элемент по ключу job, возвращая его значение

print(email)
print(job)
print(info)
```

выводит:

```no-highlight
timyr-guev@yandex.ru
Teacher
{'name': 'Sam', 'age': 28}
```

Единственное отличие этого способа удаления от оператора `del` — он возвращает удаленное значение. В остальном этот способ идентичен оператору `del`. В частности, если удаляемого ключа в словаре нет, возникнет ошибка `KeyError`.

​Чтобы ошибка не появлялась, этому методу можно передать второй аргумент. Он будет возвращен, если указанного ключа в словаре нет. Это позволяет реализовать безопасное удаление элемента из словаря:

```python
surname = info.pop('surname', None) 
```

Если ключа `surname` в словаре нет, то в переменной `surname` будет храниться значение `None`.

### Метод popitem()

Метод `popitem()` удаляет из словаря **последний добавленный элемент** и возвращает удаляемый элемент в виде кортежа `(ключ, значение)`.

Приведенный ниже код:

```python
info = {'name': 'Bob',
     'age': 25,
     'job': 'Dev'}

info['surname'] = 'Sinclar'

item = info.popitem()

print(item)
print(info)
```

выводит:

```no-highlight
('surname', 'Sinclar')
{'name': 'Bob', 'age': 25, 'job': 'Dev'}
```
​   В версиях Python ниже 3.6 метод `popitem()` удалял случайный элемент.

### Метод clear()

Метод `clear()` удаляет все элементы из словаря.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

info.clear()

print(info)
```

выводит:

```no-highlight
{}
```

### Метод copy()

Метод `copy()` создает **поверхностную** копию словаря.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

info_copy = info.copy()

print(info_copy)
```

выводит:

```no-highlight
{'name': 'Bob', 'age': 25, 'job': 'Dev'}
```

Не стоит путать копирование словаря (метод `copy()`) и присвоение новой переменной ссылки на старый словарь.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

new_info = info
new_info['name'] = 'Tim'

print(info)
```

выводит:

```no-highlight
{'name': 'Tim', 'age': 25, 'job': 'Dev'}
```

Оператор присваивания (`=`) не копирует словарь, а лишь присваивает ссылку на старый словарь новой переменной.

![](https://ucarecdn.com/95fb3a80-5be7-4b57-ac79-713a933d596d/)

Таким образом, когда мы изменяем словарь `new_info`, меняется и словарь `info`. Если необходимо изменить один словарь, не изменяя второй, используют метод `copy()`.

Приведенный ниже код:

```python
info = {'name': 'Bob',
        'age': 25,
        'job': 'Dev'}

new_info = info.copy()
new_info['name'] = 'Tim'

print(info)
print(new_info)
```

выводит:

```no-highlight
{'name': 'Bob', 'age': 25, 'job': 'Dev'}
{'name': 'Tim', 'age': 25, 'job': 'Dev'}
```

## Примечания

**Примечание 1.** Словарь можно использовать вместо нескольких вложенных условий, если вам нужно проверить число на равенство. Например, вместо:

```python
num = int(input())

if num == 1:
    description = 'One'
elif num == 2:
    description = 'Two'
elif num == 3:
    description = 'Three'
else:
    description = 'Unknown'

print(description)
```

можно написать:

```python
num = int(input())

description = {1: 'One', 2: 'Two', 3: 'Three'}

print(description.get(num, 'Unknown'))
```

На практике такой код встречается достаточно часто, особенно если в программе необходимо часто осуществлять проверку указанного типа.